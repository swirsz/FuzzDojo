Timestamp,What Fuzz Dojo and OSS-Fuzz projects did you work on?,What functions in the project did you try before achieving success and why did you choose them?  What fuzz driver files (ie: new_fuzzer.cc) did you modify?,2. Creating/modifying fuzz driver code and debugging compiling issues,3. Compiling the project and using different sanitizers,4. Resolving fuzzing issues such as slow operations and low coverage,5. Running the tools to check for improved code coverage,6. How would you compare the usability of the Fuzz Dojo challenges compared to the OSS-Fuzz challenges?,"Beyond compiling and checking for code coverage, what Fuzz Dojo features and tools did you find useful?","What actions did you take outside the platform? (for example: webpages, other tools)",Which features did you use?,Did you find any crashes when using the platform?,How would you rate the usability of the Fuzz Dojo?,"How would you rate the training videos, links, and exercises?","Different fuzzing environments lead to unstable/unreliable results. When these machines have different environments, the consistency of the fuzzing output can be affected or disrupted. Examples: different Python versions and different Linux builds.  (F1) ","Incompatibility between the fuzzing environment and the project leads to build failures. Compiler updates and versioning, specifically, can break fuzzing builds and require complex manual intervention from the developers to fix the problem. (F2) ",Bad fuzz drivers lead to fuzzing failure or inconsistent results. (F6),Issues with fuzzing test code lead to crashes/build failures. (F7),"Bugs in the fuzzer lead to build failures or abnormal / inconsistent fuzzing behaviors. This includes fuzzers not being able to detect known positive cases, generating false positives, reporting the wrong type of failure, or simply crashing. (F8)",Incorrect use of the corpus leads to fuzzing failures or low coverage. (F9),"Issues with the build tools or external dependencies lead to crash/build failures. For example, docker images have grown too big over time. (F10)",Issues in the corpus (such as unreadable or bad data) lead to build failures or unreliable results. (F11),"Developers have difficulties generating the correct inputs or targeting specific parts of the software. For example, a fuzz driver achieving only shallow coverage or being unable to pass strict pre-condition checks. (F15) ","Developers have difficulties in setting up, building, or using the fuzzer. This includes breaking the build, not fuzzing the right fuzz target, causing the fuzzer to use too much memory, and many other issues. (F16)","Documentation on how to use the fuzzer is missing/ insufficient. For example, finding information on how to utilize optional features of a fuzzing tool. (F17)","Messages/information generated by fuzzers is missing / confusing/unhelpful. For example, crushing outputs are found but not reported. (F18)","Bad code design limits the ability to fuzz. This includes insufficient segmentation/separation of the target code, monolithic design, and assumptions about intended behavior, often requiring tests be done on the full system. (F20)",Developers have difficulties writing/understanding and debugging fuzzing code. (F21),Developers have difficulty deciding which parts of the software to fuzz. (F22),Have you encountered other challenges not mentioned in this survey?,Do you have any general suggestions for how the platform or the fuzzing process could be improved?
2025/04/09 9:00:10 PM MDT,elfutils,"I chose functions related to dwarf parsing, I went through the fuzz-introspector undiscovered complexity and saw those weren't being covered. I ended up fuzzing functions related to getting location information from variables.","I didn't have many issues with this, the rebuild command worked well","I compiled it using /challenge/build, I didn't try different sanitizers",I did notice the harness is somewhat slow and coverage was just below the needed amount but I just made some changes to the corpus and called a few more library functions to get the required coverage.,"running /challenge/loc was pretty slow, a lot of my time was spent waiting for it to finish",I stopped when I got the flag,"the report feature, to view what parts of my harness and the target were hit","I looked at the source code repo, searched for uses of some library functions on github, and checked fuzz-introspector","""LOC"" coverage calculators;Fuzz Introspector;Corpus",No,4,4,5 - Never,5 - Never,5 - Never,4 - Rarely,3 - Sometimes,3 - Sometimes,5 - Never,4 - Rarely,3 - Sometimes,3 - Sometimes,4 - Rarely,4 - Rarely,4 - Rarely,3 - Sometimes,3 - Sometimes,"sometimes a few of the harnesses would break, e.g., the /challenge/loc command would report them finding no coverage, I'm not sure what the cause was, restarting the challenge fixed it","it could be nice if the existing harnesses didn't always get executed on /challenge/loc, it takes a while to evaluate the coverage from all of the harnesses when most of the time I only wanted to check if the coverage improved from changes to my harness"
2025/09/15 1:33:33 PM MDT,unrar and boost,"unrar was almost entirely unfuzzed, which was odd, so I fuzzed the command line parser (which with sanitizers on finds some spicy bugs already). For boost the project was well-covered already for the most part so it was painful to improve coverage by finding new functions to cover. Instead it was far better to add seed corpora, to improve e.g. fuzzing of json and regex parsing.","unrar was small and trivial to compile, so the turnaround for making a change and seeing how well it compiled and fuzzed was short. boost was a nightmare with multiple fuzzers and a long build time. If I wanted to try a change to see if it really would improve coverage the turnaround was very lengthy.","compiling out of the box was very easy with both versions, though I don't know how I would enable address sanitizer with the fuzz-dojo version","this was project specific as well, for unrar this was trivial but for boost this was a nightmare. ",,"for unrar, when I felt the command line parser was covered. for boost, when I finally got the flag as I was sick of boost by that point","The simplicity of the fuzz-dojo commands are a blessing in themselves. They map very well to the happy path of ""build"" ""coverage check"" and ""see the breakdown in the report"", which is the majority of what I wanted to do","I checked the public introspector for the current oss-fuzz projects, to check if the projects I got were up to date and see where there was already some improvements. There wasn't, though boost somehow had more coverage (smarter corpora perhaps?) but checking upstream is something I'd do anyway.","""LOC"" coverage calculators;Fuzz Introspector;Corpus;Address Sanitizer;Memory Sanitizer",No,4,3,5 - Never,5 - Never,3 - Sometimes,5 - Never,4 - Rarely,2 - Often,5 - Never,2 - Often,2 - Often,5 - Never,3 - Sometimes,5 - Never,2 - Often,2 - Often,2 - Often,,
2025/09/25 4:11:06 PM MDT,casync,"Function before achieving success: ca_compress
Reason: It is the parent of other compression functions.
Function for fuzz harnesses: N/A or I don't understand the question.",fuzz-dojo is straight-forward. However oss-fuzz dojo is not good. I didn't know if I should modify /src-none or /src-orig.,"The build lock file (/tmp/build.lck) cannot be deleted by normal user. If I accidentally Ctrl-C a long running build command, I cannot run the next build, unless I restart the challenge. ",Use fuzz-introspector,Use /challenge/loc or infra/help.py coverage,When /challenge/loc gives me flags.,It gives me a working directory at ~/fuzz-dojo/ and copy files to respectively /src-* dir.,oss-fuzz introspector site.,"""LOC"" coverage calculators;Fuzz Introspector;Dictionary",No,3,4,4 - Rarely,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,3 - Sometimes,5 - Never,5 - Never,5 - Never,4 - Rarely,No,First few practice challenges have /challenge/loc requires increasing coverage. But simply running /challenge/training is enough to get the flag.
2025/10/03 8:24:46 AM MDT,Vorbis and Kamailio,"In Kamailio I tried LOADS of functions. I spent a long time trying to get main2 and yyparse to fuzz but there was so much global state that the fuzzer kept crashing and I couldn't work around it.
Eventually I made lots of different drivers but the biggest contributions came from:
1. pp_substdef_add
2. pp_subst_run
3. fix_rval_expr
4. sr_kemi_core_match_method_id (Lots of individual sr_kemi methods are in the fuzzer)

In Vorbis I chose vorbis_analysis_wrote as I wanted to hit mapping0_forward as it was high on the list of functions to be fuzzed for vorbis according to the oss-fuzz project ","Lots of issues when the functions were dealing with shared memory and global variables. There were lots of functions that looked appealing that were inline static and I struggled to know how to actually fuzz it.
The function I struggled to fuzz and gave up on was yyparse, it would just hang no matter what I tried when trying to fuzz it",I didn't use different sanitizers. For compilation I ended up declaring a lot of the functions in my fuzzer and linking to the library as they weren't declared in header files (this didn't work for static functions).,I'm afraid if it wasn't obvious I'd turn to chatgpt and if that didn't help I'd look for another function to fuzz,"Running /challenge/loc was simple enough although I had to do a bit of searching of the scripts to see how to provide a .options file so I could get them to run in fork mode.
Also /challenge/loc would hang on one of my fuzzers so I had to manually wait until it hung, press ctrl+c and then it would proceed

Once I figured out how to use the infra/helper.py for oss-fuzz that was quite smooth.",fuzz dojo was simpler until trying to get it to do something that wasn't the default behaviour e.g. fork and ignore_crashes. Once I understood oss-fuzz I preferred it personally as I felt it was something I could go away and use outside of the dojo,Once I found the options file option I liked that,"I would use chatgpt to help identify a good target from a source file and get advice on how to fuzz it, if it wasn't at simple as just pass it the fuzz data.
I'd also use the oss-fuzz project pages to identify possible good functions to call","""LOC"" coverage calculators",Yes,3,4,4 - Rarely,4 - Rarely,1 - Always,1 - Always,5 - Never,5 - Never,5 - Never,5 - Never,1 - Always,1 - Always,2 - Often,4 - Rarely,2 - Often,1 - Always,2 - Often,"I found it tough to fuzz targets that were inline static functions.

I wasn't sure if I was allowed to change the source code of the project I was fuzzing so I didn't",I think an example of fuzzing a difficult function would be awesome. Something like yyparse in the Kamailio project as I was absolutely stumped in figuring out how to do that.
2025/10/03 3:12:14 PM MDT,"avahi, unrar, snappy, cjson, lighttpd1.4, tmux","I chose functions which were easily callable, having few arguments. Arguments mostly were strings and integers, but there were some cases when I had to pass structs. By choosing these functions I tried to maximize the line coverage. I modified new_fuzzer driver. If there was not such, I modified the existing one. ","I had no problems with creating or modifying the fuzz drivers, except Level 1.0 Practice. It didn't create a directory in fuzz-dojo where I could modify the harness. I had to search for the fuzz driver in the other places, which took me a while.",No problems,"Adding a few functions made the coverage grow sufficiently. Only tmux challenge made me call a vast amount of functions, since each of them was slightly increasing the total line coverage.",No problems,"Fuzz Dojo challenges made it easy to build, run and report. In the beginning, for OSS-Fuzz challenges I struggled to execute commands in the correct order. Once I figured it out everything went well. ",I liked that command execution was easy.,I had to look into source codes and introspector reports.,"""LOC"" coverage calculators;Fuzz Introspector;Corpus",Yes,5,5,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,3 - Sometimes,I don't know,3 - Sometimes,I don't know,4 - Rarely,4 - Rarely,I don't know,4 - Rarely,4 - Rarely,4 - Rarely,4 - Rarely,No,Add more challenges
2025/10/05 2:33:27 PM MDT,"cjson, unrar, openjpeg","For example, in openjpeg I looked at the coverage report, chose the file that had the most lines but least coverage, picked the functions that were the biggest and searched for calls to those functions in other functions ""going up the tree"". In this case I ended up with compress and decompress functions, so if I fuzzed them, I would get the most coverage gain.",Modifying fuzz drivers and debugging compiler issues was straightforward,Compiling the project was really simple and I faced no issues here,"After modifying the fuzz driver, I repeatedly observed zero coverage in the reports. The root cause was that the driver wasn’t exercising the instrumented code paths, so the fuzzer never generated or saved any coverage-increasing inputs. Since no interesting inputs were added to the corpus to reach new code paths, the coverage report correctly showed 0%. Once I understood this, everything became clear. The reason why we sanitize it for coverage after fuzzing is that sanitized code runs much slower, and saving the only inputs that increase the coverage will be fewer and running them less time-consuming.","It took a lot of time to build the projects every time, with and without sanitizer, to check the improvement after also waiting 30 seconds for the fuzzer to finish. I would say 80% of the time was taken by the building process.","I had fewer problems with Fuzz Dojo challenges compared to OSS-Fuzz challenges, since in Fuzz Dojo challenges, we just run one command and it does everything for us, whereas in OSS-Fuzz challenges, I couldn't pinpoint if the problem was me not knowing how to build and run the fuzzer or if something was wrong with the challenge, etc.","I liked that we were given a directory where we should have changed the fuzz driver. It was really hard to know which src-* directories I should have changed in OSS-Fuzz challenges(made debugging even harder). Also, I liked the building tools; I could just run them, and it would do everything on its own while I was doing something else.","I used LLM (ChatGPT) to help me write a fuzz driver. I gave it the functions to call, and it wrote everything correctly, so I wouldn't waste more time figuring out the correct way to call those functions.","""LOC"" coverage calculators;Fuzz Introspector",No,4,5,5 - Never,5 - Never,3 - Sometimes,I don't know,5 - Never,3 - Sometimes,5 - Never,5 - Never,I don't know,5 - Never,4 - Rarely,I don't know,5 - Never,4 - Rarely,5 - Never,No,No
2025/10/19 7:21:05 PM MDT,snappy & guetzli,"Well, it was hinted for targeting iovec inside snappy, but at first I played around mostly with uncovered uncompress paths while trying to replicate your style of thought. I'm not at all familiar with C++ though and it was hard to get all of these attempts compiled. I did manage to make some big boosts by myself, but I did have to try finding resources for what even are iovecs. I fully intend on revisiting this again because it was very fun thanks to your guidance! My current solution is an absolute slop mess but I want to take the time to really try to understand what's going on and make an improvement I can feel proud of. I've learned a ton though and am now prepared to fuzz in the future! These projects are fun puzzles and a fantastic opportunity to learn many different concepts quick through trial by fire.","Thanks to the instructor, I was able to learn most of what I needed when issues arose. The fuzz dojo still had some quirks(e.g. the last training solution feels awkward to get to), but I found the alternate tooling you made for us easier to use than the standard default route.",I didn't really use any other sanitizers other than what you had for default. I managed to overcome any issues regarding the dojo itself pretty quick. I don't know how to utilize the other sanitizers for benefiting yet.,The case studies did really well at showing what to do! I have nothing else to contribute to the optimizations as I'm extremely new to this.,"If I remembered to use rebuild instead of outright going, the tools made things very easy!","Much more convenient, though on my main machine, I'd likely prefer to use OSS-Fuzz, as I want to be able to have more control over things personally. However, if the dojo concept magically could assume how to make additional fuzz drivers work, it'd be a no brainer.",The rebuild was useful and abstraction of injecting fuzzers was really convenient. (Though I really appreciate you kicking us out of the bird nest fast!!),"Before getting started with the dojo, I tried looking into fuzzing through hunter's dojo (just pwn.college archive), but that wasn't really much of learning. So, I started reading the newly released book ""from day zero to zero day"". I'm not done with reading it, but it helped me understand a lot of what to do here, as I felt too clueless how to approach prior; though I do not blame the dojo for this, as it was more of I lacked manual code analysis understanding.

Also, at the end I tried AI admittedly, and it near one shot the guetzli challenge, but I believe because I took quality notes on your videos(tried my best to pay attention! This was a very intimidating concept for me prior.), I was able to apply the understanding for crafting a prompt containing the necessary heavily informative context in order for it to succeed. This is definitely not infallible; it'll create issues that weren't there and why it's important for human supervision. I'm not quite sure how I could've succeeded in the guetzli challenge elsewise though, given what it was and how much coverage existed already.","""LOC"" coverage calculators;Fuzz Introspector",No,4,5,4 - Rarely,4 - Rarely,3 - Sometimes,2 - Often,I don't know,I don't know,3 - Sometimes,5 - Never,I don't know,I don't know,4 - Rarely,3 - Sometimes,I don't know,I don't know,I don't know,Nothing immediately comes to mind. I hope my answers were adequate!,"If you're new to low level programming, even after completing the main pwn.college curriculum, code analysis can be incredibly intimidating. There's so much going on and it's hard to figure it out. You did a fantastic job showing your mental approach to these challenges, but I feel something could be developed further, whether it be introducing automated forms of code analysis, using proper terminology, I'm not sure. But these are my own anxieties speaking, ones that I must practice vulnerability researching in order to overcome; I'm new to this all!"
2025/10/20 10:58:27 PM MDT,Vorbis and zlib,,,,,,,,,"""LOC"" coverage calculators;Fuzz Introspector",Yes,5,5,3 - Sometimes,1 - Always,2 - Often,2 - Often,2 - Often,2 - Often,I don't know,4 - Rarely,I don't know,3 - Sometimes,2 - Often,4 - Rarely,2 - Often,I don't know,3 - Sometimes,,
2025/10/21 10:32:06 PM MDT,Fuzz Dojo: fuzz~c7f7b8c2. Introduction to Fuzzing and Real World Fuzzing. Projects: All projects (Level 2.0 and 2.1),"In the project I targetted encoding functions because the fuzzers were just doing decoding and decompression. The report showed that the encoding modules like dwt.c and all had 0% coverage. Also the description mentioned that encoding functions were not covered.
I did not modify existing fuzzers. I created a new file encode_fuzzer.cpp that creates image data from fuzzer input and calls opj_encode() instead of opj_decode(). This went through the entire encoding pipeline that had no testing before, which took the coverage from 5% to over 22%.","I used encode_fuzzer.cpp by writing code that initializes an opj_image_t structure, encoding options, and then calls the OpenJPEG compression routines.
It crashed at first because I had not initialized the output stream with write, seek and skip callback functions. The encoder tried to write into a NULL stream that caused a segfault.
I fixed it by making a MemStream structure with a memory buffer and calling mem_write, mem_seek, and mem_skip callback functions. Then I had registered these callbacks correctly with opj_stream_set_write_function, opj_stream_set_seek_function, and opj_stream_set_skip_function prior to calling opj_encode. That allowed the encoder to write to memory instead of crashing.",I constructed the project with ./rebuild that adheres to the build script. I don't know why the terminal was simply showing build in progress all the time even if it wasn't. Restarting the environment fixed it. The project already had the settings to compile with sanitizers. I made no edits to sanitizer settings. The fuzzer used UndefinedBehaviorSanitizer automatically that is why it was able to catch the segfault in my original version and print the crash along with the stack trace. I used whatever sanitizers were already configured in the build system.,"The main issue was really low coverage at 5% because all the existing fuzzers were only testing the decoding side of the library. When I looked at the coverage reports, I noticed huge parts of the code like the encoding functions had zero coverage.
To fix this, I made a new fuzzer that does encoding instead of decoding. The idea was to take random data from the fuzzer, use it to create a fake image, and then try to compress it. This way the fuzzer would actually run through all the encoding code that wasn't being tested before.
The first time I tried it crashed pretty quickly because I messed up the stream setup. I had to add proper callback functions so the encoder could actually write its output somewhere. After fixing that, it ran fine and the coverage went to 22% which was enough to pass the challenge.",I just ran ./loc command to check the coverage percentage. It showed the initial coverage was 5% and after running my encode_fuzzer it went 22%. The tool automatically compared it against the target and showed that I passed the requirement.,I think OSS-Fuzz challenges are kind of harder.,"The ./fuzz-introspector command was helpful because it showed me which functions and files weren't being covered. The coverage reports in JSON format were also useful but of course, the full webpage that showed detailed coverage report was too good as well. 
I could see the percentages for each file and figure out that what functions had 0% coverage.",The resources (links) that were provided in the challenge (official google website) were helpful. I also took help of AI for challenges that were being too difficult and my code was not working well for them. I understood where my code changes were lacking behind and used the concepts in further challenges.,"""LOC"" coverage calculators;Fuzz Introspector;Corpus;Undefined Behavior Sanitizer",Yes,4,4,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,5 - Never,5 - Never,5 - Never,5 - Never,3 - Sometimes,4 - Rarely,4 - Rarely,4 - Rarely,5 - Never,2 - Often,2 - Often,"Yes, it was difficult to start the coverage report server twice in the same session. Like, when we start it once and then kill it, and try to start it again later, the webpage either says socket hanged or 404. This happened even after killing port 8008.",I believe fixing small network related issues like I mentioned earlier would be great. Overall the fuzzing process was really good.
2025/10/22 12:43:46 AM MDT,"only oss-fuzz ( LibreOffice , json, libpng, etc)",I don't recall.,Of course,Generally use asan,I use a privately modified parallel version of aflpp.,yes,,,,"""LOC"" coverage calculators;Corpus;Dictionary;Address Sanitizer;Memory Sanitizer;Undefined Behavior Sanitizer;Private Kasan implementation",,,,4 - Rarely,2 - Often,3 - Sometimes,2 - Often,5 - Never,1 - Always,3 - Sometimes,3 - Sometimes,2 - Often,3 - Sometimes,4 - Rarely,5 - Never,2 - Often,2 - Often,4 - Rarely,"Closed-source programs, non-host architecture programs, bare-metal programs, and drivers",
2025/10/23 6:59:09 PM MDT,"Unrar and openjpeg2 were my ""real-life"" targets","I honestly tried a ton of different functions. I used coverage reports to identify under-fuzzed sections of code. For example, although the unrar_fuzzer targets the extract functionality, major parts of that file were still untouched. That is how I ultimately landed on targeting the ExtractCurrentFile function. As for openjpeg2, I noticed tiling functionality was under-fuzzed, and modified this test file: https://github.com/uclouvain/openjpeg/blob/1ad9bec2c12ee445ce23e660f5e4fe870b9d5e09/tests/test_tile_decoder.c to serve as a fuzzing driver.","It was really just an iterative process. Especially for codebases without a ton of reference code, I looked for function usage in the library itself and used the help of LLM's to guide the harnessing process.","This was pretty straightforward overall. I think my biggest challenge here was understanding how locally modifying a project for oss-fuzz works, and how the /src-orig, etc. directories are created and used.","Really just trial and error. As soon as I noticed a harness wasn't immediately gaining coverage, I knew something was wrong.",The coverage tool was great here. It made browsing the codebase for under-fuzzed targets easy.,"I would say the Fuzz Dojo challenges were easier to use than OSS-Fuzz challenges. But for future reference,  I think a more in-depth explanation on how to modify and run these challenges would be helpful!",That was about everything :) ,"Manpages, source repo, stackoverflow, LLM, anything else that referenced the codebase ","""LOC"" coverage calculators;Corpus;Address Sanitizer",No,4,5,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,5 - Never,4 - Rarely,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,3 - Sometimes,2 - Often,,"As I mentioned a few questions ago, I think a more comprehensive guide on how to modify the build and fuzzing drivers for a target for both fuzz dojo and oss-fuzz challenges would be helpful. Overall this was a great time! Thank you for putting in the effort for this great learning experience."
2025/11/06 1:04:51 PM MST,"openjpeg, casync","adapted already prepared fuzz drivers like fuzz-compress.c  and used functions in test cases like ca_digest_write , ca_sync_step as data sink for the harness","checking the build.sh for the make file, adapting it to a single file and compiling that , then i used that to debug my errors",,i checked the function overview page order by undiscoverd complexity then investigate with function name by tracing on github,i use the function call tree from the introspector to check for which functions are covered and which are not,"The fuzz DOjo challenges are better, highlighting improvement in code coverage makes this way easier with /loc. The abstraction of running individual fuzzers too makes Fuzz dojo challenges more useable","/challenge/rebuid , find-drv , ",Browsing github source code of the projects,"""LOC"" coverage calculators;Fuzz Introspector;Corpus",Yes,4,3,2 - Often,1 - Always,1 - Always,3 - Sometimes,3 - Sometimes,1 - Always,2 - Often,3 - Sometimes,2 - Often,1 - Always,1 - Always,1 - Always,1 - Always,3 - Sometimes,3 - Sometimes,None,
2025/11/11 4:31:57 PM MST,"openjpeg, cJSON, snappy","I chose the functions by reading the code coverage and the drivers already present, so that I could understand which parts of the code had not been covered. The only function I modified in the driver is LLVMFuzzerTestOneInput, because I didn't need anything else.",I had no problems.,I had no problems.,I had no problems.,I had no problems.,"The tools provided by Fuzz Dojo are obviously much more convenient, but not very customizable, and for challenges I think that's fine.","They were all useful: build, loc, report, fuzz-introspector, etc.",I have read the documentation for libfuzzer and oss-fuzz.,"""LOC"" coverage calculators;Fuzz Introspector;Address Sanitizer;Memory Sanitizer;Undefined Behavior Sanitizer",No,5,4,5 - Never,5 - Never,5 - Never,5 - Never,5 - Never,4 - Rarely,5 - Never,5 - Never,4 - Rarely,4 - Rarely,3 - Sometimes,I don't know,3 - Sometimes,5 - Never,I don't know,No,It would be great to continue the series by exploring other fuzzers such as AFL.
2025/11/29 11:48:39 PM MST,"cJSON, openjpeg, unrar",mainly focused on the parsing functions; ended up creating new drivers and modifying build scripts,"yes, the setup had to be learned",just used the default sanitizers,n/a,introspector,OSS-Fuzz dojo is the standard but requires initial learning,introspector,,"""LOC"" coverage calculators;Fuzz Introspector;Corpus;Address Sanitizer;Undefined Behavior Sanitizer",No,3,3,I don't know,3 - Sometimes,3 - Sometimes,3 - Sometimes,3 - Sometimes,3 - Sometimes,3 - Sometimes,I don't know,2 - Often,2 - Often,2 - Often,2 - Often,2 - Often,2 - Often,2 - Often,,
2025/11/30 8:55:21 PM MST,snappy (Fuzz Dojo) and guetzli (OSS),"For snappy, I tried RawCompress() and RawCompressFromIOVec(). I chose these because the sink and source style classes were the major cause for uncovered code in snappy. By specifically triggering these classes, I aimed to increase coverage. I later realized I should use slightly higher level functions that called these functions. I edited ""new_fuzzer.cc"".

For guetzli, I tried Downsample() because it calls many sub functions related to the output image and image manipulation that had not been covered. However, I ran into issues of an invalid state due to certain requirements on the JPEG image passed. I chose to call a different function that had was higher level, which had less requirements on the JPEG, and called many (but not all) of the same functions. I edited ""fuzz_target.cc"".","I used vim to modify the already existing file for both projects. For Fuzz dojo, I used the new_fuzzer.cc created automatically. For the OSS-project, I briefly tried to create a new fuzz driver but was unsuccessful and decided to append to the preexisting file. For compilation issues, I ran the compilation command and diagnosed errors. Admittedly, I took a very inefficient approach because for each compilation, I recompiled everything. I was not sure how to only recompile the fuzz driver for both tools. I tried rebuild for Fuzz-dojo but that still appeared to recompile everything.","I used ""python3 infra/helper.py build_fuzzers guetzli $PWD/../guetzli/"" for OSS-fuzz and ""/challenge/build"" for Fuzz-Dojo. I used the coverage and memory sanitizers by adding the appropriate flag. The coverage was necessary to get the flag and determine the increase in coverage. The memory sanitizer was used to diagnose a bug in my fuzz driver, which caused it to crash (I had forgotten to update array dimensions in a function call).","Admittedly, I never saw my exec/s anywhere. To diagnose low coverage, I looked at the coverage report generated to see how coverage had changed after updating the fuzz driver and identify new areas to target. At first, I ran into the issue of small coverage increases, which was due to poor initial target selection.","I used the coverage report for the OSS-fuzz project but mainly used ""/challenge/loc"" for Fuzz-Dojo.","Fuzz Dojo challenges were way more usable and abstracted away the unnecessary details like adding my new fuzz driver to the project. Instead, I could immediately start working on my new fuzz driver and quickly determine if I had increased code coverage. For OSS-fuzz, I ran into issues of losing my code coverage or not compiling correctly, forcing me to restart the fuzz compiling, running, and code coverage generation process.",Those were the main features I used. I briefly used the fuzz-introspector,I consulted the OSS-Fuzz coverage report for both projects externally and used Github to quickly track down function references across the repo. I also briefly consulted Docs and Google when confused about the functionality of certain functions.,"""LOC"" coverage calculators;Fuzz Introspector;Memory Sanitizer",No,5,4,5 - Never,5 - Never,3 - Sometimes,2 - Often,5 - Never,5 - Never,5 - Never,5 - Never,2 - Often,4 - Rarely,4 - Rarely,3 - Sometimes,5 - Never,3 - Sometimes,2 - Often,,
2025/12/02 3:39:31 AM MST,"I did only the 5th first trainings (Locate Harnesses to Improve Coverage Using The Call Tree), and the 4 real world challenges.","My strategy was only to launch a first coverage, look which functions were not called/files with low coverage, and call them. I simply appended the new calls in existing, ready to compile, fuzz drivers (new_fuzzer.cc or others, like target_fuzzer.cc for guetzli).","I had a lot of issues on the OSS part, mostly because there is a lot of obscurity in ""what"" is compiled, ""where"" it is stored, etc... I think I spend roughly 1 day and half only on guetzli to investigate the build process inside the challenge, not even focusing on the fuzzing itself. It was really a pain. In the end, I understood there where an issue with the build.sh script which was in my local project (guetzli, git-cloned and appended to hlpers.py command when needed), and the build.sh located at the root of /src (because that one is copied for /opt/oss-fuzz/projects...). And so even if you try to make your build.sh on your local project work when adding a new fuzzer, you have no idea why it does not work.

I had a similar issue with seed corpus training, where I could not understand what was not working... Still because of the multiple overlays there is for the challenge. For instance, I didn't understand why I was supposed to have 2 branches in a fuzzer that was calling only 1 function ? And why the error when launching /challenge/loc was that my fuzzer took only 1 branches over 2 ?","I didn't try much other sanitizers tbh, I didn't debug much my fuzzers","When the build process was ok, it was easy as ""looking into the source code"" to understand why it wasn't reaching the coverage I was expected it to reach. When the building process was complicated (like.. The source code in the report coverage of my own fuzzer was NOT the code I was expecting to have), it was more complicated. 

I didn't have much slow operations honestly, the max_total_time=30 was ok to reach decent results.",Nothing special other than what I already told for the Implement Seed Corpus training.,"I had a much easier experience with the Fuzz Dojo challenges. I think it is more because the OSS-Fuzz toolchain is clear and well documented, but when you hit the challenges, there are overlays and hooks everywhere... You almost don't call the python helper directly, etc etc... This caused additional difficulties for me.",N/A,A bit of cpp documentation or initialization I would say.,"""LOC"" coverage calculators;Address Sanitizer",Yes,3,2,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,I don't know,I don't know,5 - Never,I don't know,5 - Never,2 - Often,4 - Rarely,4 - Rarely,5 - Never,I don't know,5 - Never,N/A,N/A
2025/12/03 4:57:39 PM MST,"1.0: CJSON (OSS-Fuzz), 1.1: CJSON (Fuzz Dojo), 2.0: openjpeg (OSS-Fuzz), 2.1: unrar (OSS-Fuzz)","In openjpeg I spent a bunch of time looking at different formats (like tiff) because I could see mentions of them in the tests (and I was hoping their own examples would show me how to correctly call the APIs), but in the end I focused on recompressing the data that the original fuzzer was uncompressing. So, I actually created a ""new_fuzzer.cpp"" (I expected to then have to hack some build scripts to get it to build the fuzzer but the provided ""build_google_oss_fuzzers.sh"" meant I didn't need to) but should probably have just modified ""opj_decompress_fuzzer_JP2.cpp"".

In unrar, I went straight to the introspector report, looked up the highest function (which happened to be ""CommandData::ProcessCommand()"", this didn't look super fun to try and call directly, so I called some lower level switch handling functions instead - my intention was to then work up from there to higher level stuff, but it wasn't needed - might go back future and have a play with that though).","To be honest, once I fixed the issues of building the original code (use the 'insert some bad code deliberately and then double-tripple-check it is in fact building from the file that I think it is building from' trick we got there). There were a surprising number of scripts that fell over when it tried to recreate a directory. I found I liked the 'infra/helpers.py' script from OSS-Fuzz, but it did sort of hide away what it was up to (which made some of the debugging a bit trickier).","With the fuzz dojo versions this was really slick running '/challenge/build' and then '/challenge/loc' (the notes mention '/challenge/rebuild' but this didn't actually seem to be a thing.

When I got to the OSS-Fuzz exercises, it certainly felt a bit clunkier (having to list each of the fuzzers to generate coverage rather than having options to run multiple felt a little sad). I ended up building my own wrapper to do the running of the fuzzers for 30 seconds - but then I forced myself to not include the subsequent commands for generating the coverage report because the syntax was a little funky and I wanted to try and force myself to learn it.

I didn't play too much with different sanitizers (just stuck with 'none' and 'coverage') as I wasn't really looking to actually find bugs.","Didn't have any issues with slow operations. For low coverage I was mostly just using the coverage reports (in terms of the source code to test and the fuzz driver itself) - running for 30 seconds, seeing what code was still not being hit. One thing I do still need to figure out is how, when there is a low number of cases that hit a certain bit of the code, to then somehow figure out a test case that did hit that - probably a workflow I need to think on.","I was using the ""Desktop workspace"", so I was just using firefox to browse to the served up pages (once the reports had been served up either through '/challenge/loc' or 'python3 infra/helper.py coverage --no-corpus-download <project>').","Much slicker. Sounds funny to say, but they made the experience more ""fun"", I could skip a lot of the figuring out where to put things (or what command to run and where I had to cd to first) and just move through the workflow to the actually looking at the existing drivers and the reports. I also felt it made switching to another OSS-Fuzz project a more familiar experience (would probably encourage me to jump between projects more to find one I was interested in digging into as eerything feels a little more standardised) ",The familiarity and standardisation - again it just made it easy to get up and going when switching to a new project. Even just the 'find-drv' bit made it really quick to jump in and start reading the existing drivers to get a feel for the sort of testing already happening.,I used the web interface for the actual git repos for the projects (I find the search within there is quite nice) and a few tutorials libFuzzer tutorials (just to get inspiration for the way do things like creating temp directories during a test case),"""LOC"" coverage calculators;Fuzz Introspector;Corpus;Dictionary",No,4,4,4 - Rarely,3 - Sometimes,3 - Sometimes,3 - Sometimes,3 - Sometimes,2 - Often,3 - Sometimes,3 - Sometimes,2 - Often,3 - Sometimes,2 - Often,3 - Sometimes,2 - Often,3 - Sometimes,2 - Often,"No, I think all the issues were covered",I felt I could have done  bit more on the corpus side if there were helpers of minimising a corpus (I'm thinking like afl-cmin and afl-tmin)
2025/12/04 2:20:10 AM MST,OSS-Fuzz: Guetzli Fuzz-Dojo: Snappy,"For Guetzli, the description.md mentions the downsample code has 0% coverage and should be the prime target, so I used the 2 functions declared in the header files preprocess_downsample.h, RGBToYUV420() and PreprocessChannel().

For Snappy, there are no clear directions given in the description. Browsing the introspector page suggests RawUncompressToIOVec() as an uncovered function and it is relatively easy to fuzz (since I don't understand how to create a source/sink that is used internally by other uncovered snappy functions)

For both challenges I wrote the fuzzer from scratch.","Most the time the issue comes from not understanding how to build the large projects, I don't have much experience in build tools like cmake and automake so I have to spend a lot of time on understanding those instead of writing actual code. The dojo infra also does too much ""magic"" behind the scene and gives really ambiguous message when something goes wrong",Same as above,"I think the two projects I got are relatively easy to get a 5% increase in coverage, but I have no idea if my fuzz driver is actually good",,"Adding new fuzz drivers is much easier obviously, since different projects have different built requirement that is just abstracted away by the fuzz dojo tools, I can also start editing my new fuzz driver code right away",Are there any? Lol,Most of the time is reading oss fuzz docs and introspector pages,"""LOC"" coverage calculators;Fuzz Introspector;Corpus;Address Sanitizer",No,3,3,4 - Rarely,2 - Often,2 - Often,3 - Sometimes,5 - Never,5 - Never,5 - Never,5 - Never,4 - Rarely,3 - Sometimes,2 - Often,4 - Rarely,5 - Never,I don't know,I don't know,,
2025/12/08 5:29:25 PM MST,guetzli snappy,,,,,,It was very easy to use compared to OSS-Fuzz,,,,Yes,5,,,,,,,,,,,,,,,,,,
2025/12/13 1:40:13 PM MST,openjpeg and unrar,"unrar: CommandData. openjpeg: opj_j2k_read_header, opj_j2k_read_tile_header, opj_j2k_decode_tile, opj_j2k_read_siz, opj_j2k_update_image_data, opj_jp2_read_header, opj_jp2_read_boxhdr, opj_jp2_read_ihdr, opj_jp2_read_colr, opj_jp2_read_pclr, opj_jp2_read_cmap","just copy the existing drivers, check for gaps in coverage, and modify new drivers to call those missing functions",#NAME?,tears and determination,python3 infra/helper.py coverage (this command is burned into my subconscious now),Fuzz Dojo challenges were less buggy. But i preferred the oss-fuzz challenges because those are the commands im going to run in the future,none really,I'm not sure what you mean by this. I would use googles fuzz introspector webpages.,"""LOC"" coverage calculators;Fuzz Introspector;Corpus;Undefined Behavior Sanitizer",Yes,5,5,3 - Sometimes,3 - Sometimes,3 - Sometimes,4 - Rarely,3 - Sometimes,2 - Often,1 - Always,5 - Never,4 - Rarely,3 - Sometimes,5 - Never,5 - Never,I don't know,4 - Rarely,3 - Sometimes,,"get rid of the fuzz-dojo, just stick with oss-fuzz"
2025/12/18 10:21:15 AM MST,casync (fuzz dojo) and openjpeg (OSS-Fuzz),"casync: fuzz-new.c calls compressor_decode, my first pick was compressor_encode because it sounded significant enough (in retrospect, I should have put it in its own file, but it was enough to flag)
openjpeg: I started with small functions in the API of openjpeg.h like opj_version, opg_image_create but it wasn't enough coverage. I looked at available tests to pick the next functions. My second idea was to rip test_tile_encoder.c but opj_image_data_alloc would hit the out-of-memory limit of 2Go every time. After the mem limit got upgraded, I set out to implement the encoding part based on testempty2.c but the fuzzer was stuck on opj_start_compress(l_codec, image, l_stream); and I still have no idea what's wrong. 
In the end, *none* of the code I wrote was useful, I noticed in the github history that when they split the fuzzers for JP2 and J2K to their own files, they didn't split the seed corpus file so it wasn't used. I solved it by making a seed corpus file for each existing fuzzer.","casync was fairly straight-forward, like other examples in the dojo, 
openjpeg: I had a hard time figuring the build system and how to add a fuzzer, it turns out that there was a glob on .cpp files but it took me a while to figure out between CMakeLists.txt, GNUMakefile, build_google_oss_fuzzers.sh, build.sh, Dockerfile","casync was fairly straight-forward, like other examples in the dojo
openjpeg: I hit `mkdir: cannot create directory ‘build’: File exists` and didn't see the discord fix, it took me a while to find where the build directory was. Other than that, I used the commands in the slides for OSS-Fuzz Driver Development","casync: didn't have any slow operations and low coverage
openjpeg: I implemented the encoding part from png to J2K, with a seed corpus of pngs, but I could not solve the low coverage issue, my fuzzer was stuck on opj_start_compress(l_codec, image, l_stream);","casync: just run loc
openjpeg: used the commands for coverage report and introspector in the slides for OSS-Fuzz Driver Development","fuzz-dojo challenges are way easier to use than OSS-Fuzz challenges
My main problem with the OSS-Fuzz challenges is that they're close to a real environment but have some hidden magic or limitations: the inability to set -rss_limit_mb, the copying to /src or /out, ...","the ability to reset the platform when I break everything :')))
I have the nasty habit of doing ctrl-c during builds :/","for openjpeg, I spent a lot of times in their wiki and browsing the source code on github
I used ltrace to have a better understanding of opj_compress and the encoding process","""LOC"" coverage calculators;Fuzz Introspector;Corpus",Yes,4,3,5 - Never,5 - Never,4 - Rarely,4 - Rarely,4 - Rarely,3 - Sometimes,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,2 - Often,2 - Often,3 - Sometimes,2 - Often,4 - Rarely,,"It would be nice to have challenges for all the features not currently covered: how to use a dictionary, custom mutators, other sanitizers"
2025/12/19 9:41:56 AM MST,"Can't recall all of them, for fuzz dojo i had different random projects and i had cjson for the practice and openjpeg for the real world project .","Can't recall, usually removing extra if/else and adding new object manipulation functions, i also modified some boundary checking functions which were blockers . Also adding object deletion functions . And removing input validation functions which allowed for more random data thus triggering error handling uncovered code blocks .","Nothing significant, except for the 'build files exist' error which required removing the <Project>/build/ directory, which was easy to figure and was correctly addressed by @Dadris on Discord and explained where the files exist .
Also switching the build directory between the Fuzz Dojo and Real World fuzzing was bit confusing at first since files existed on both $HOME/<project> and at /src-coverage/none directories .

Also noticed slight change in commands used in the Real World fuzzing by switching from python3 infra/helper.py based commands at the practice challenges to getting back to using same /challenge/<loc/build/rebuild> commands at the real world projects, not major but can be confusing .",Basically used the coverage sanitizer for all the challenges .,"Usually fuzz driver issue that is part of the challenge, such as Fuzz Dojo challenges where it required removing extra if / else logic .

Also removing some input validation functions allowed for more coverage and faster fuzzing .","Was the confusing part, since first you use /challenge/loc then you use python3 infra/helper.py coverage command on other challenges .","The Fuzz Dojo challenges are more of guided in terms of tooling, so they can be useful to introduce the fuzzing basics but they hide lot of operations that are mandatory for learning fuzzing .

The tooling of OSS-Fuzz challenges are easy to use and allow you to understand the principles .

Both are usable, except for that participants need to pay attention to the output to figure what directories are used which also saved time for setup .","The DESCRIPTION.md, since Fuzz Dojo is mostly guided in terms of tooling .","Searching for Fuzz Introspector reports and trying to setup ClusterFuzz which failed due to some recent restrictions i believe .

Also searching how to expand coverage on specific projects but the Fuzz Dojo videos were the most useful as resource . Though bit lengthy .","""LOC"" coverage calculators;Fuzz Introspector;Corpus;Address Sanitizer",Yes,5,4,1 - Always,1 - Always,1 - Always,I don't know,1 - Always,2 - Often,1 - Always,4 - Rarely,1 - Always,1 - Always,3 - Sometimes,I don't know,1 - Always,1 - Always,1 - Always,"Different build tools ? but was learning opportunity not an obstacle . Easily figured through ossfuzz.sh

Also one issue is that the platform crashes by logging me out of the ssh session or restarting the terminal / desktop if a command is mistyped : infra/help.py instead of infra/helper.py makes it crash .","Improve the shell so it doesn't crash when mistyping commands (infra/help.py -> helper.py)
Use unified build tools for the OSS-Fuzz challenges for both Practice and Real World challenges instead of switching back to /challenge/<loc/build ...> from python3 infra/help.py <coverage/build_fuzzers ...>

Other than that great community and responsive team, special thanks for you ."
2025/12/31 2:24:05 AM MST,Guetzli and Snappy,"For Guetzli, there is only one file to use. I started with writing fuzzer for functions: DecodeJpegToRGB, PreProcessChannel and RGBToYUV420 because there was 0 coverage in preprocess_downsample.c file and number of regions were large to warrant high coverage.

For Snappy, I copied snappy_compress_fizzer.cc. I started with functions that uses 'Source' and 'Sink' or 'struct iovec'  as input. It was difficult to prepare those inputs first. So, I looked around the code and found examples in the 'snappy_unittest.cc' file. which helped me understand how inputs are being used","Since it was a CTF style challenge, I didn't come up with any quick compile idea. If I had to do it for a longer time, I would figure out a way to compile fuzzers without any oss-fuzz commands or dojo commands to build and run them.

Some times the issue was with the bad input instead of the library code, I had learned from the logs generated about the actual issue.","I read the oss-fuzz documentation and watch the training videos on the fuzz-dojo module.
I wrote a script to show me what commands to run based on the target project. It came in handy.","I guess I didn't face any slow operations. But, at some point I got coverage lower than the initial number. It was because of some exception thrown for any type of data. So, actual code was never run.","I used bash script to either display the commands to run or run them directly.
The coverage is only available on the desktop session, which became a problem.
One issue I faced was that the dojo desktop session blanked out after some time of inactivity. I either used curl for basic coverage numbers. or I had to restart the session to use the desktop.
","Fuzz dojo challenges are no doubt easier to run and debug.
Rebuild script was pretty handy in checking for compilation errors.
I think 'build' and 'loc' script has some fuzzer specific commands, which I didn't spent much time to understand. If they are useful, it would be good to know what all things we can do with those scripts.","Not sure if it answers the question, but other tools are:
tmux, ssh, dojo desktop, vim","I watched videos on youtube related to fuzzers, read oss-fuzz documentation, searched for other similar fuzzers on github","""LOC"" coverage calculators",Yes,5,4,5 - Never,5 - Never,5 - Never,3 - Sometimes,3 - Sometimes,I don't know,5 - Never,5 - Never,5 - Never,4 - Rarely,2 - Often,5 - Never,5 - Never,I don't know,3 - Sometimes,"I don't have much experience in C, C++, so I had a little difficulty in understanding how to include a new fuzzer in the build pipeline.",NA
2026/01/09 4:59:48 AM MST,"cjson, openjpeg and unrar are main",Modified newfuzzer.c or newfuzzer.cpp and removed lot of conditional statements,No issues both Cmake and Make were easy,Only coverage,if statements caused slow,Only provided tools,Both good but practice are easy,Used only compiling,Asked AI little,"""LOC"" coverage calculators;Fuzz Introspector;coverage sanitizer",No,4,4,3 - Sometimes,2 - Often,2 - Often,3 - Sometimes,3 - Sometimes,3 - Sometimes,4 - Rarely,5 - Never,2 - Often,3 - Sometimes,5 - Never,5 - Never,2 - Often,1 - Always,1 - Always,No,No
2026/01/09 6:51:06 AM MST,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
2026/01/09 7:15:06 AM MST,Real World project,,,,,,,,,,,4,4,3 - Sometimes,3 - Sometimes,,,,3 - Sometimes,4 - Rarely,,,,,,,,,,
2026/01/09 7:46:12 AM MST,,LLVM function,,,,,,,Blogs and Github,"""LOC"" coverage calculators;Fuzz Introspector",Yes,3,3,,,,,,,,,,,,,,2 - Often,2 - Often,,
